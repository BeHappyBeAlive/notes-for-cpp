#include<iostream>
#include<algorithm>
using namespace std;


#if 0
template<typename T>
class AVLTree
{
public:
	AVLTree() :root_(nullptr) 
	{

	}

	//AVL树的插入实现
	void insert(const T& val) {
		root_ = insert(root_, val);
	}
	void remove(const T& val) {
		root_ = remove(root_, val);
	}
private:

	//定义树的节点
	struct Node 
	{
		Node(T data = T())
			:data_(data),
			left_(nullptr),
			right_(nullptr),
			height(1)
		{

		}
		T data_;
		Node* left_;
		Node* right_;
		int height;
	};

	int height(Node* node)
	{
		return node == nullptr ? 0 : node->height;
	}


	//右旋转操作 以node节点为轴做右旋转操作，并把新的根节点返回
	Node* rightRotate(Node* node)
	{
		Node* child = node->left_;
		node->left_ = child->right_;
		child->right_ = node;
		//高度更新
		node->height = max(height(node->left_), height(node->right_)) + 1;
		child->height = max(height(child->left_), height(child->right_)) + 1;

		//返回旋转后的子树新的根节点
		return child;
	}

	//左旋转操作 以node节点为轴做左旋转操作，并把新的根节点返回
	Node* leftRotate(Node* node)
	{
		Node* child = node->right_;
		node->right_ = child->left_;
		child->left_ = node;
		//高度更新
		node->height = max(height(node->left_), height(node->right_)) + 1;
		child->height = max(height(child->left_), height(child->right_)) + 1;

		//返回旋转后的子树新的根节点
		return child;
	}

	//左平衡操作 以参数node，其左孩子为轴做左旋转操作，然后对node根节点做右旋转操作
	Node* leftBalance(Node* node) {
		node->left_ = leftRotate(node->left_);
		return rightRotate(node);
	}

	//右平衡操作 以参数node，其右边孩子为轴做右旋转操作，然后再以node节点做左旋转操作
	Node* rightBalance(Node* node) {
		node->right_ = rightRotate(node->right_);
		return leftRotate(node);
	}

	Node* insert(Node* node, const T& val) {
		if (node == nullptr) { //递归找到了插入的位置
			return new Node(val);
		}
		if (node->data_ > val) {
			node->left_ = insert(node->left_, val);
			//添加1 在递归回溯时判断节点是否失衡 node的左子树太高了 node失衡了
			if (height(node->left_) - height(node->right_) > 1) {
				//节点失衡 左孩子的左子树太高了
				if (height(node->left_->left_) >= height(node->left_->right_)) {
					node = rightRotate(node);
				}
				else
				{
					//左孩子的右子树太高了
					node = leftBalance(node);
				}
			}
		}
		else if (node->data_ < val) {
			node->right_ = insert(node->right_, val);
			//添加2 在递归回溯时候 判断节点是否失衡 node的右子树太高了node失衡了
			if (height(node->right_) - height(node->left_) > 1) {
				//节点失衡 右孩子的右子树太高了
				if (height(node->right_->right_) >= height(node->right_->left_)) {
					node = leftRotate(node);
				}
				else
				{
					//右孩子的左子树太高了
					node = rightBalance(node);
				}
			}
		}
		else
		{
			; //找到相同节点了，不用向下递归了，直接向上回溯
		}
		//添加3 子树中因为增加了新的节点 在递归回溯时候检测更新节点高度
		node->height = max(height(node->left_), height(node->right_)) + 1;
		return node;
	}

	Node* remove(Node* node, const T& val) {
		if (node == nullptr) {
			return nullptr;
		}
		if (node->data_ > val) {
			node->left_ = remove(node->left_, val);
			//添加1 左子树删除节点，可能造成右子树太高了
			if (height(node->right_) - height(node->left_) > 1) {
				if (height(node->right_->right_) >= height(node->right_->left_)) {
					//右孩子的右子树太高了
					node = leftRotate(node);
				}
				else
				{
					//右孩子的左子树太高了
					node = rightBalance(node);
				}
			}
		}
		else if (node->data_ < val) {
			node->right_ = remove(node->right_, val);
			//添加2 右子树删除节点 可能导致左子树太高了
			if (height(node->left_) - height(node->right_) > 1) {
				//左孩子的左子树过高
				if (height(node->left_->left_) >= height(node->left_->right_)) {
					node = rightRotate(node);
				}
				else
				{
					//左孩子的右子树过高
					node = leftBalance(node);
				}
			}
		}
		else
		{
			//找到了
			//先处理有两个孩子节点的删除操作
			if (node->left_ != nullptr && node->right_ != nullptr) {
				//添加3 为了避免删除前驱或者后继节点造成节点失衡，则谁高删除谁
				if (height(node->left_) > height(node->right_)) {
					//删除前驱
					Node* pre = node->left_;
					while (pre->right_ != nullptr) {
						pre = pre->right_;
					}
					node->data_ = pre->data_;
					node->left_ = remove(node->left_, pre->data_); //删除前驱节点
				}
				else
				{
					//删除后继
					Node* post = node->right_;
					while (post->left_ != nullptr) {
						post = post->left_;
					}
					node->data_ = post->data_;
					node->right_ = remove(node->right_, post->data_);//删除后继节点
				}
			}
			else
			{
				//删除节点最多有一个
				if (node->left_ != nullptr) {
					Node* left = node->left_;
					delete node;
					return left;
				}
				else if (node->right_ != nullptr) {
					Node* right = node->right_;
					delete node;
					return right;
				}
				else {
					delete node;
					return nullptr;
				}
			}

		}

		//更新节点高度
		node->height = max(height(node->left_), height(node->right_)) + 1;


		return node; //回溯过程中，将当前节点给其父节点返回

	}
	Node* root_;
};




int main() {
	AVLTree<int> avl;
	for (int i = 1; i <= 10; i++) {
		avl.insert(i);
	}
	avl.remove(9);
	avl.remove(10);
	avl.remove(6);
	avl.remove(1);
	avl.remove(2);
	avl.remove(3);

	return 0;
}
#endif