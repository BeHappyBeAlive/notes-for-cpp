#include<iostream>
#include<thread>
#include<mutex>
#include<condition_variable> // 条件变量
#include<queue> // C++ STL所有的容器都不是线程安全的
using namespace std;

/*
C++多线程编程 - 线程间的同步通信机制
多线程编程两个问题：
1. 线程间的互斥
	竞态条件 =》 临界区代码段 =》 原子操作 =》 线程互斥锁mutex 轻量级的无锁实现CAS
	strace ./a.out mutex => pthread_mutex_t
2. 线程间的同步通信
	生产者、消费者线程模型

*/
std::mutex mtx; // 定义互斥锁
std::condition_variable cv; //定义条件变量，做线程间的同步通信操作

// 生产者生产一个物品，通知消费者消费一个；消费完了之后，消费者通知生产者继续生产
class Queue {
public:
	void put(int val) { // 生产物品
		//lock_guard<std::mutex> guard(mtx); //scoped_ptr
		unique_lock<std::mutex> lck(mtx); // unique_ptr
		while (!que.empty()) { 
			// que不为空，生产者应该通知消费者去消费，消费完了再生产
			// 生产者线程应该进入阻塞#1等待状态，并且#2把mtx互斥锁释放掉
			
			cv.wait(lck);
		}
		que.push(val);
		/*
			notify_one:通知另外一个线程
			notify_all:通知其他所有线程
			通知其他线程我生产了一个物品，赶快消费
			其他线程得到该通知，就会从等待状态 =》 阻塞状态 =》 获取互斥锁才能继续执行
		*/
		cv.notify_all(); 
		cout << "生产者 生产：" << val << "号物品" << endl;
	}
	int get() { // 消费物品
		//lock_guard<std::mutex> guard(mtx);
		unique_lock<std::mutex> lck(mtx);
		while (que.empty()) {
			//消费者发现que为空，通知生产者线程先生产物品
			//#1 进入等待状态 #2 把互斥锁mutex释放掉
			
			cv.wait(lck);
		}
		int val = que.front();
		que.pop();
		cv.notify_all(); //通知其他线程我消费完了，赶快生产吧
		cout << "消费者 消费：" << val << "号物品" << endl;
		return val;
	}
private:
	queue<int> que;
};

void producer(Queue *que) //生产者线程
{
	for (int i = 1; i <= 10; ++i) 
	{
		que->put(i);
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}

}

void consumer(Queue* que) //消费者线程
{
	for (int i = 1; i <= 10; ++i)
	{
		que->get();
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}

}

int main() {
	Queue que; // 两个线程共享的队列

	std::thread t1(producer, &que);
	std::thread t2(consumer, &que);

	t1.join();
	t2.join();
}
