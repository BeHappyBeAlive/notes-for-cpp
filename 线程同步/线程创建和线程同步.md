# Linux线程的创建与同步

## 1. 线程概念

### 1. 概念

线程：进程内部的一条执行路径或者序列

进程：一个正在执行的程序，是动态运作的

### 2. 多个线程、进程之间

多个线程共享进程的资源

多个进程各自拥有各自的资源

### 3. 例子

从main函数的第一行执行到最后一行，这就叫做一个线程

一个程序段里面两个函数，main函数执行和thread_fun函数就是一个进程的两个执行序列，即一个进程里面的两个线程

进程与线程是相辅相成的，不能完全将其分隔开，二者分不开，从调度执行看的是线程角度，从资源分隔方面看的是进程

可以形象的比做一场羽毛球，1班和2班去比赛就是进程之间，1班的张三和2班的李四进行比赛就是线程



### 4. 线程的创建

![image-20210504145158597](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504145158597.png)

第一个参数指的是线程id，可以传入线程的id

第二个参数指的是线程的相关属性

第三个参数是一个函数指针

第四个参数是对第三个参数中的函数指针的参数

### 5. 代码示例

![image-20210504150106743](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504150106743.png)

这地方如果直接编译链接就会报错，因为编译器默认从标准库里面找函数，但是这个库是在pthread库里面，需要在编译链接的时候指定库名

![image-20210504150317147](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504150317147.png)

就像上面这样，报错是链接阶段错误

需要指定库名，如下面这样：

![image-20210504150428976](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504150428976.png)

为什么只看见了main？

因为创建线程需要一定时间，但是主线程运行时间很短，可能直接结束之后没有等到fun执行，就结束了整个进程，这个时候不管存不存在线程，都会全部销毁，为了看到两个都执行的效果，我们可以让主线程输出代码部分下面睡眠几秒，等待一下thread_fun线程

![image-20210504150720181](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504150720181.png)

![image-20210504150826353](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504150826353.png)



先打印一个main fun，再打印一个thread fun，让两个都等待，处理器交替运行，两个线程并发运行

![image-20210504151131071](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504151131071.png)

![image-20210504151103408](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504151103408.png)

## 2. 线程的并发

### 1. 并发与并行

并发是某一段时间a与b两个进程交替运行

并行指的是某一段时间内，a与b两个进程同时运行，但是其实现需要硬件支持

### 2. 线程退出与等待

主线程执行结束之后，子线程不能继续执行了

所以这里面可以在主线程执行完毕之后，执行退出线程的操作，使得主线程结束，但是这个时候进程还未退出，子线程还可以执行

![image-20210504152224785](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504152224785.png)

执行之后，会有下面的效果

![image-20210504152252521](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504152252521.png)

但是我们一般的逻辑是所有子线程结束之后，主线程才结束，这里面调用线程等待函数，如下面所示：

![image-20210504152355520](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504152355520.png)

运行结果：

![image-20210504152531826](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504152531826.png)

### 3. 函数参数举例

#### 3.1 五个进程并发运行

创建五个线程，理解参数该如何赋值

![image-20210504154957323](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504154957323.png)

运行上面的代码我们可以得到下面的效果

![image-20210504155110985](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504155110985.png)

#### 3.2 线程修改临界资源

一共是五组在一段时间里面同时执行，即在1秒之内五个线程各执行一次，i代表第几次执行，说明五个线程并发运行

但是将出传入的参数改变，改变为取i的地址

![image-20210504160807253](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504160807253.png)

![](C:\Users\ZHURUI\Desktop\5.gif)

这里面拿最好的那个例子来解释吧，就是五个进程的index都是0的时候，由于创建线程太慢了，程序已经跑到了下面这个for循环里面了，程序获取的index值为0，而且这个时候每一个线程都执行等待，也就导致了后面一直index都是0，但是这种情况是不一定的，每次的值都会不一样

为了更好的理解并发，创建一个全局变量，创建五个进程，对这个全局变量进行改变

![image-20210504161131720](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504161131720.png)

那么正常的理解是最后g的值会累加到4999，因为这里是g++，不是++g，但是如果是一个处理器，并且是单核的处理器的话，就会出现少数据的情况，这种原因就是，在当前线程修改这个全局变量的值的时候，由于g++不是原子操作，所以其操作会被其他线程打断，这个时候会使得这两个线程只++了一次这个全局变量，我虚拟机暂时设置不了单处理器单核，所以演示不了这种情况，大概就是下面这种情况：

> 0
>
> ···
>
> n

这里面n是小于4999的正整数

#### 3.3 线程修改临界资源加信号量控制

那么如何解决这种情况，还是一个就是加pv操作，对临界资源进行控制

所以需要设置信号量

![image-20210504163407745](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504163407745.png)

那么现在执行这个程序，可以累加到5000，这里面将后置++改变为前置++

如下图：

![](C:\Users\ZHURUI\Desktop\5.gif)

#### 3.4 思考的作业

![image-20210504170836486](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504170836486.png)

结果：

![image-20210504170935242](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504170935242.png)

## 3. 为什么要采用多线程？

1. 同时做多件事情
2. 利用多处理器的资源，一个处理器运行一个线程

## 4. 线程同步

### 4.1 线程安全的函数

解决上面的作业

![image-20210504165006906](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504165006906.png)

结果：

![image-20210504170935242](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504170935242.png)

上面这个函数是线程不安全的，因为在多个线程在进行strtok的时候，线程之间在没执行完之前会来回strtok分割，而这个时候就会有覆盖掉前面值的风险，所以是线程不安全的，所以要使用线程安全的函数

![image-20210504171553707](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504171553707.png)

带_r表示线程安全，这里面的第三个参数表示一存放当前分割字符串分别指向字符串的哪个位置

我们修改之后

![image-20210504172026911](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504172026911.png)

![image-20210504172137953](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504172137953.png)

### 4.2 信号量机制实现同步

![image-20210505103548831](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505103548831.png)

![image-20210505103608194](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505103608194.png)

![image-20210505103626176](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505103626176.png)

![image-20210504173059513](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504173059513.png)

![image-20210504173117719](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210504173117719.png)

采用信号量机制实现两个线程输出不被其他线程打断

![image-20210505103422383](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505103422383.png)

![image-20210505103254178](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505103254178.png)



### 4.4 互斥锁实现同步

![image-20210505103912914](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505103912914.png)

![image-20210505103920917](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505103920917.png)

为什么没有？？？

![image-20210505104156117](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505104156117.png)

安装manpages可以查看：

```bash
sudo apt-get install manpages-posix-dev
```

![image-20210505105840543](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505105840543.png)

![image-20210505105941173](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505105941173.png)



### 4.5 条件变量

条件变量提供了一种线程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的所有线程。

![image-20210505110247174](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505110247174.png)

![image-20210505112144402](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505112144402.png)

![image-20210505112157844](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505112157844.png)

运行结果

![](C:\Users\ZHURUI\Desktop\5.gif)

在pthread_cond_wait之前加锁，后面解锁就是为了防止多个线程在等到信号量满足条件之后执行紊乱的情况出现，加上锁之后就不会出现这种情况，若正在唤醒线程的时候，这个时候某个线程正在进行操作，那么我们在唤醒线程前后也要加锁：

改进之后：

![image-20210505113115949](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505113115949.png)

![image-20210505114938032](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505114938032.png)

![image-20210505114957219](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505114957219.png)

运行程序

![image-20210505114731291](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505114731291.png)

如何看三个线程

```bash
ps -eLf  //中间的L显示线程id
```

![image-20210505114714921](C:\Users\ZHURUI\AppData\Roaming\Typora\typora-user-images\image-20210505114714921.png)

线程的实现：在Linux中是通过进程方式实现的

strace跟踪系统调用

ltrace跟踪库函数

```
strace ./cond1
```

